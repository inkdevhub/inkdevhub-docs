# How to do cross-contract calls

## Prerequisites

This tutorial targets developers with basic knowledge of ink! and a basic level in Rust.

### To follow this tutorial you will need:

- To [set up your ink! environment](https://docs.inkdevhub.io/docs/learn/build-environment/ink_environment)

### What will we do?

In this tutorial, we will learn how to do cross-contract calls.

### What will we use?

- [ink! 4.2.0](https://github.com/paritytech/ink/tree/v4.2.0)
- [cargo-contract 3.2.0](https://github.com/paritytech/cargo-contract/tree/v3.2.0)
- [substrate-contracts-node](https://github.com/paritytech/substrate-contracts-node)

# Cross-contract calls

This is a step-by-step explanation of how to implement cross-contract calls in ink! smart contracts.

## What are cross-contract calls?

In ink! contracts it is possible to call messages and constructors of other contracts. This process is called *cross-contract calls*.

# How to define and use cross-contract calls?

Let’s create learning contracts to understand how events work. There are a few methods how to do cross-contract calls:

- `ContractRef` — refers to structs that are generated by the ink! code generation for cross-contract calls. They give developers a type-safe way of interacting with a contract. You need to import the contract you want to call as a dependency of your contract. You can’t use it to call a contract that is already deployed.
- `CreateBuilder` — an easy way for you to instantiate a contract. Same as in `ContractRef`, you will still need a reference for your contract. It’s similar to the previous method, but it provides a little bit more flexibility.
- `CallBuilder` — gives you a couple of ways to call messages from other contracts. With this method, you can make `Call`s and `DelegateCall`s.

## 1) Define initial contracts

In a new project folder, execute the following:

```bash
cargo contract new flipper # flipper is introduced from the beginning.
```

And create `MainContract` and make it clear for now. We will call `Flipper` from it.

```bash
cargo contract new main_contract
```

Filename: 
main_contract/lib.rs

```rust
#![cfg_attr(not(feature = "std"), no_std, no_main)]

#[ink::contract]
mod main_contract {
    #[ink(storage)]
    pub struct MainContract {}

    impl MainContract {
        #[ink(constructor)]
        pub fn new(init_value: bool) -> Self {
            Self
        }
    }
}
```

## 2) ContractRef

As mentioned above, to use `ContractRef` we need to import a reference to your contract that you want to call to our `MainContract`. 

First, give `FlipperRef` public access.

Filename: 
flipper/lib.rs

```rust
#![cfg_attr(not(feature = "std"), no_std, no_main)]

//Give `FlipperRef` public access
pub use self::flipper::FlipperRef; 

#[ink::contract]
mod flipper {
...
}
```

Secondly, add `Flipper` as dependency to `MainContract` in `Cargo.toml`

Filename: 
flipper/lib.rs

```toml
[dependencies]
...
flipper = { path = "../flipper", default-features = false, features = ["ink-as-dependency"] }
...
[features]
...
std = [
...
	"flipper/std",
]
```

Thirdly, import `FlipperRef` in `MainContract`.

Filename: 
main_contract/

lib.rs

```rust
#[ink::contract]
mod main_contract {
    use flipper::FlipperRef;
...
}
```

To save its instance we will create a storage field that stores `FliperRef`. 

Filename: 
main_contract/

lib.rs

```rust
#[ink(storage)]
pub struct MainContract {
    flipper: FlipperRef,
}
```

And finally, we can instantiate `Flipper` contract. We will do it in the constructor and save in `flipper` field in storage.

Filename: 
main_contract/

lib.rs

```rust
impl MainContract {
    #[ink(constructor)]
    pub fn new(code_hash: Hash, init_value: bool) -> Self {
        let flipper = FlipperRef::new(init_value)
            .code_hash(code_hash)
            .endowment(0)
            .salt_bytes([0xDE, 0xAD, 0xBE, 0xEF])
            .instantiate();
        Self { flipper }
    }
}
```

Now we have an instance of `Flipper` and we can call it now. Let’s crate functions `flip` and `get` that simply call `Flipper`’s methods with same names.

Filename: 
main_contract/

lib.rs

```rust
impl MainContract {
    ...
		#[ink(message)]
		pub fn flip(&mut self) {
		    self.flipper.flip();
		}
		
		#[ink(message)]
		pub fn get(&self) -> bool {
		    self.flipper.get()
		}
}
```

Let’s deploy contracts and test how it works. As mentioned before, we can’t call other contracts if it’s not instantiated in the network. So first we need to build `Flipper` and upload it.

```bash
cargo contract build --manifest-path flipper/Cargo.toml
cargo contract upload --manifest-path flipper/Cargo.toml --suri //Alice -x
```

Now we have the `code_hash` of the `Flipper` contract uploaded to the network. 

```bash
Code hash 0xc264a93fef7117d04fad5a4bc4925c962d9ab1d9a565cadb419f93e559ebeb71
```

And we can use it to deploy `MainContract`.

```bash
cargo contract build --manifest-path main_contract/Cargo.toml
cargo contract instantiate \
		--manifest-path main_contract/Cargo.toml \
    --constructor new \
    --args 0xc264a93fef7117d04fad5a4bc4925c962d9ab1d9a565cadb419f93e559ebeb71 true \
    --suri //Alice \
		-x -y
```

If everything is successful, you will see the address of the contract.

```bash
Contract 5E1qsGrY7p2M5fCVeGiE6UPrw59xMpwmGbErMUA7X3WL9KqT
```

That’s all! Now we have deployed a contract that can do cross-contract calls to the `Flipper`. Let’s test how it works.

```bash
cargo contract call --manifest-path main_contract/Cargo.toml \
--contract 5E1qsGrY7p2M5fCVeGiE6UPrw59xMpwmGbErMUA7X3WL9KqT \
--suri //Alice \
--message get
```

We should get something similar, because initial value of `Flipper` is true.

```bash
Result Ok(true)
Reverted false
```

Let’s try to `flip` it and see what we get:

```bash
cargo contract call --manifest-path main_contract/Cargo.toml \
--contract 5E1qsGrY7p2M5fCVeGiE6UPrw59xMpwmGbErMUA7X3WL9KqT \
--suri //Alice \
--message flip \
-x \
-y

cargo contract call --manifest-path main_contract/Cargo.toml \
--contract 5E1qsGrY7p2M5fCVeGiE6UPrw59xMpwmGbErMUA7X3WL9KqT \
--suri //Alice \
--message get
```

We see that the contract flips value in `Flipper`.

```bash
Result Ok(false)
Reverted false
```

## 3) **CreateBuilder**

`CreateBuilder` is pretty similar to `ContractRef`. All difference is in the syntax of instantiating the contract by `code_hash`. To use `CreateBuilder` follow all steps from the `[ContractRef` section](https://www.notion.so/How-to-do-cross-contract-calls-57990f5dbf634dc48922a7108c177a5a?pvs=21), but replace the instantiating contract with:

Filename: 
main_contract/

lib.rs

```rust
impl MainContract {
    #[ink(constructor)]
    pub fn new(code_hash: Hash, init_value: bool) -> Self {
        let flipper : FlipperRef = build_create::<FlipperRef>()
            .code_hash(code_hash)
            .gas_limit(0)
            .endowment(0)
            .exec_input(
                ExecutionInput::new(Selector::new(ink::selector_bytes!("new")))
                    .push_arg(init_value)
            )
            .salt_bytes(&[0xDE, 0xAD, 0xBE, 0xEF])
            .returns::<FlipperRef>()
            .instantiate();

        Self { flipper }
    }
...
}
```

Now we can test it and make sure that it works like the previous method.

## 3) **CallBuilder**

With `CallBuilder` you can call messages from other contracts that are already instantiated in the network. There are two ways to use `CallBuilder` :

- `Call`
- `DelegateCall`

### Call

Let’s build a call in a new message `flip_call` and `get_call`.

Filename: 
main_contract/

lib.rs

```rust
impl MainContract {
	  #[ink(message)]
    pub fn flip_call(&mut self, contract_address: AccountId) {
        build_call::<DefaultEnvironment>()
            .call(contract_address)
            .gas_limit(0)
            .transferred_value(0)
            .exec_input(
                ExecutionInput::new(Selector::new(ink::selector_bytes!("flip")))
            )
            .returns::<()>()
            .invoke();
    }

    #[ink(message)]
    pub fn get_call(&self, contract_address: AccountId) -> bool{
        build_call::<DefaultEnvironment>()
            .call(contract_address)
            .gas_limit(0)
            .transferred_value(0)
            .exec_input(
                ExecutionInput::new(Selector::new(ink::selector_bytes!("get")))
            )
            .returns::<bool>()
            .invoke()
    }
}
```

As you can see, these use the address of the contract that has already been deployed to the network. So we should deploy our `Flipper` first.

```bash
cargo contract instantiate \
		--manifest-path flipper/Cargo.toml \
    --constructor default \
    --suri //Alice \
		-x -y
```

```bash
Contract 5DaiKstjdJxqr87xdp2e4tWNJXghySJ1X7mRbPBeNFpQ6puz
```

Now we have the address of `Flipper` and we can call its methods from `MainContract`. Let’s deploy build and deploy `MainContract`.

```bash
cargo contract build --manifest-path main_contract/Cargo.toml &&\
cargo contract instantiate \
		--manifest-path main_contract/Cargo.toml \
    --constructor new \
    --args 0xc264a93fef7117d04fad5a4bc4925c962d9ab1d9a565cadb419f93e559ebeb71 true \
    --suri //Alice \
		-x -y
```

```bash
Contract 5EhV43qsuLae3GRSy6Qp9Zh8rgnzQV7tYFHuDECSTZZBcNYR
```

Let’s test it and make sure it works well.

```bash
//Returns `Ok(false)`
cargo contract call \
	--manifest-path main_contract/Cargo.toml \
	--contract 5EhV43qsuLae3GRSy6Qp9Zh8rgnzQV7tYFHuDECSTZZBcNYR \
	--suri //Alice \
	--message get_call \
	--args 5DaiKstjdJxqr87xdp2e4tWNJXghySJ1X7mRbPBeNFpQ6puz

//Flips 
cargo contract call \
  --manifest-path main_contract/Cargo.toml \
  --contract 5EhV43qsuLae3GRSy6Qp9Zh8rgnzQV7tYFHuDECSTZZBcNYR \
  --suri //Alice \
  --message flip_call \
  --args 5DaiKstjdJxqr87xdp2e4tWNJXghySJ1X7mRbPBeNFpQ6puz \
	-x -y

//Returns `Ok(true)`
cargo contract call \
	--manifest-path main_contract/Cargo.toml \
	--contract 5EhV43qsuLae3GRSy6Qp9Zh8rgnzQV7tYFHuDECSTZZBcNYR \
	--suri //Alice \
	--message get_call \
	--args 5DaiKstjdJxqr87xdp2e4tWNJXghySJ1X7mRbPBeNFpQ6puz
```

### DelegateCall

Let’s build a delegate call in a new message `flip_delegate` and `get_delegate`. The difference from other methods is that you use `MainContract`’s storage instead of `Flipper`'s, but we use `Flipper`'s logic. Because of this feature, we must take storage compatibility into account. It means that we need to have all fields from `Flipper`'s storage in `MainContract`'s storage. Another big difference is that you call `Flipper` from your address, not from `MainContract`'s like in `Call`. With this method, you can create upgradeable contracts.

> There we can add a link for upgradeable contracts guide that will be created in future
> 

Let's update our storage to be compatible with Flipper's storage. Also, we will add an `addresses` field to storage. We will need it in the next steps. Don’t forget to import `ink::prelude::vec::Vec`.

Filename: 
flipper/

lib.rs

```rust
#[ink(storage)]
pub struct Flipper {
    value: bool,
    addresses: Vec<AccountId>,
}
...
#[ink(constructor)]
pub fn new(init_value: bool) -> Self {
    Self { value: init_value, addresses: Vec::new() }
}
```

Filename: 
main_contract/

lib.rs

```rust
#[ink(storage)]
pub struct MainContract {
...
    value: bool,
    addresses: Vec<AccountId>,
}
...
#[ink(constructor)]
pub fn new(init_value: bool) -> Self {
    Self { value: init_value, addresses: Vec::new() }
}
```

Now we have compatible storages. Let’s use our `addresses` to demonstrate the difference between `Call` and `DelegateCall`. We will push the account address of callee whenever a `flip` message is called. Also, we will add `get_addresses` message to check our `addresses`.

Filename: 
flipper/

lib.rs

```rust
...
#[ink(message)]
pub fn flip(&mut self) {
    self.value = !self.value;
    self.addresses.push(self.env().caller());
}
...
#[ink(message)]
pub fn get_addresses(&self) -> Vec<AccountId> {
    self.addresses.clone()
}
```

Same in `MainContract`. We will have `get_addesses_call`, `flip_delegate`, `get_delegate` and  `get_addresses_delegate`.

Filename: 
main_contract/

lib.rs

```rust
...
#[ink(message)]
pub fn get_addresses_call(&self, contract_address: AccountId) -> Vec<AccountId> {
    build_call::<DefaultEnvironment>()
        .call(contract_address)
        .gas_limit(0)
        .transferred_value(0)
        .exec_input(
            ExecutionInput::new(Selector::new(ink::selector_bytes!("get_addresses")))
        )
        .returns::<Vec<AccountId>>()
        .invoke()
}

#[ink(message)]
pub fn flip_delegate(&mut self, code_hash: Hash) {
    build_call::<DefaultEnvironment>()
        .delegate(code_hash)
        .call_flags(CallFlags::default().set_tail_call(true))
        .exec_input(
            ExecutionInput::new(Selector::new(ink::selector_bytes!("flip")))
        )
        .returns::<()>()
        .invoke()
}

#[ink(message)]
pub fn get_delegate(&self, code_hash: Hash) -> bool {
    build_call::<DefaultEnvironment>()
        .delegate(code_hash)
        .call_flags(CallFlags::default().set_tail_call(true))
        .exec_input(
            ExecutionInput::new(Selector::new(ink::selector_bytes!("get")))
        )
        .returns::<bool>()
        .invoke()
}

#[ink(message)]
pub fn get_addresses_delegate(&self, code_hash: Hash) -> Vec<AccountId> {
    build_call::<DefaultEnvironment>()
        .delegate(code_hash)
        .call_flags(CallFlags::default().set_tail_call(true))
        .exec_input(
            ExecutionInput::new(Selector::new(ink::selector_bytes!("get_addresses")))
        )
        .returns::<Vec<AccountId>>()
        .invoke()
}
```

Notice that you don’t need to instantiate another contract when you use `DelegateCall` , you may only upload it to the network. But in our example, we will instantiate `Flipper` to show the differences between `Call` and `DelegateCall`. So now we build and deploy both contracts.

```bash
//Flipper
Code hash 0xdac256919525471242bd9195414ed298288f3b6c6a7a22f27d3e3c85c6d7e028
Contract 5CY1z1Mwam3hqpTf8PhUGgHMKvAtJ8z6B5EThQuFfse29ZMW 

//MainContract
Contract 5HpmRAxgKTAR7Vzekis917eR6HR782zF7F1ritiVZp854VYu
```

Let’s call `flip_call` and then check `addresses` by `get_addresses_call`.

```bash
cargo contract call --manifest-path main_contract/Cargo.toml \
--contract 5HpmRAxgKTAR7Vzekis917eR6HR782zF7F1ritiVZp854VYu \
--message flip_call \
--args 5CY1z1Mwam3hqpTf8PhUGgHMKvAtJ8z6B5EThQuFfse29ZMW \
--suri //Alice \
-x

cargo contract call --manifest-path main_contract/Cargo.toml \
--contract 5HpmRAxgKTAR7Vzekis917eR6HR782zF7F1ritiVZp854VYu \
--message get_addresses_call \
--args 5CY1z1Mwam3hqpTf8PhUGgHMKvAtJ8z6B5EThQuFfse29ZMW \
--suri //Alice 

//Output
['5HpmRAxgKTAR7Vzekis917eR6HR782zF7F1ritiVZp854VYu'] // MainContract's address
```

As we can see, the callee in this situation is `MainContract`. Let’s see what happens if we call `flip_delegate` and `get_addresses_delegate`.

```bash
cargo contract call --manifest-path main_contract/Cargo.toml \
--contract 5HpmRAxgKTAR7Vzekis917eR6HR782zF7F1ritiVZp854VYu \
--message flip_delegate \
--args 0xdac256919525471242bd9195414ed298288f3b6c6a7a22f27d3e3c85c6d7e028 \
--suri //Alice \
-x

cargo contract call --manifest-path main_contract/Cargo.toml \
--contract 5HpmRAxgKTAR7Vzekis917eR6HR782zF7F1ritiVZp854VYu \
--message get_addresses_delegate \
--args 0xdac256919525471242bd9195414ed298288f3b6c6a7a22f27d3e3c85c6d7e028 \
--suri //Alice 

//Output
['5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY'] // Alice's address
```

As you can see in this situation callee is Alice's account, that is, the account that is called the `MainContract`. Also, as mentioned before `delegate` use `MainContract`'s storage.

# Conclusion

In this guide, we have become familiar with various methods of doing cross-contract calls and learned the differences between them.
